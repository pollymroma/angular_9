######### ANGULAR 8 #########

Repo del profe: https://danielsanchez.com.ar/AccentureAngular/

- descargo zip

Framework de Frontend MVC: Modelo-Vista-Controlador

Scafolding: estructura de carpetas.

Usa TypeScript. Tipado estatico (opcional): de qué tipo es la variable.

Los navegadores no lo soportan, no lo entienden, por eso un transpilador, traduce el código a un lenguaje base.

NodeJS plataforma de trabajo. Backend en NodeJS. JavaScript en frontend.
Angular puede trabajar con cualquier backend.
Genera una aplicacion RESTful
Desacoplado: frontend y backend. Se vinculan mediante servicios API rest.

Instalamos NodeJS: descarga desde nodejs.org

Para Angular 8 o 9 necesitamos node 12.16 actualizar.

Herramientas:
- NodeJS
- Visual Studio Code
- Algun terminal (opcion cmder, la mini)
- Git
- NPM
- Angular CLI (ng --version) Instalamos la 9

Creamos proyecto: ng new nombre:
- Routing: no. Porque lo vamos a hacer despues a mano para verlo. Mas adelante no haria falta decir no.
- Stylesheet: css

Dentro del proyecto code . ejecuta el visual estudio abierto en ese proyecto

ng serve -o abre el navegador

###############################################################################

app.module.ts: organizacion del proyecto, con cual arranca.
Componente: vista (html y css), funcionalidad (codigo)
app.component es el componente principal. Tiene su css y html (vista) su ts (codigo) y el spec.ts (testing)

Decorador: un patron de diseño.

AppComponent: la clase.
El componente tiene la clase, que es el que se declara en el modulo.
Bootstrap: con que componente se arranca.

Scafolding: la estructura de carpetas.
node_modules: dependencias del proyecto.
src -> app: modulos, componentes
app -> app.module.ts los componentes, imports, providers y bootstrap, con cual componente arranca
src -> assets: archivos de recursos: imagenes, audio, video, documentos
src -> environments: para el build y compilar
src -> favicon: el iconito en la tab de la pagina
src -> index.html el html de arranque, del proyecto, no tocarlo
tiene el <app-root> la etiqueta que levanta el componene principal
src -> style.css: estilos globales
src -> test.ts tiene que ver con cosas de test
src -> polyfills: tiene que ver con cosas de navegadores viejos?
src -> main.ts tiene en memoria el proyecto, arrancando con el AppModule. Archivo de arranque.
angular.json: estilos, rutas de las cosas. configura dependencias.
tsconfig.json: opciones del transpilador

Bootstrap 4: buscamos el css, importamos eso y no el js.
Lo metemos en el index.html abajo del favicon.
En el index.html no inyectamos mas componentes, solo queda el principal.
Los demas se meten en el app.component.html

Creamos componentes:
ng generate component ruta
ng g c ruta
ng g c componentes/entradas

alt + z wrap codigo largo
shift + alt + a comentar codigo

#ENTRADAS
Data Binding:
o Interpolacion
    mensaje en entradas.component.ts, como una variable
    En el html lo muestro con una {{}}
o Property Binding
    un atributo en un input de html
    de la clase a la vista. la vista no cambia el valor del atributo si se modificara
o Event Binding
    la vista le quiere decir algo a la clase
    por ejemplo conecto un boton con una accion que incrementa un contador
o Double Data Binding
    usando eventos: escribir un valor y que se actualice ahora si la propiedad
    MANUAL: [value] y un evento que llama una funcion y recibe un $event
    AUTOMATICO: usamos ngModel. junta el [value] y lo del evento con metodo todo en uno.
    el [] hace lo del [value] los () hace que la propiedad que pongo ahi, se reemplace por lo que meta en el input.
    importar el modulo de formularios en el app.module import { FormsModule } from '@angular/forms';
    solo para actualizar la variable

#ESTRUCTURA
Directivas Estructurales:
o *ngIf
    algo se ve o no segun el valor de lo que evalue el ngIf. No lo oculta, lo saca del DOM
    el *ngIf puede llevar un else, ;else y nombre, luego creo un ng-template con #nombre
o *ngFor
    como un for de programacion.
    index as i, una variable interna index, la llamo i

#ATRIBUTOS
o [ngStyle] 
    modifica aspecto de un elemento. aplica css con sintaxis de objeto.
o [ngClass] 
    sintaxis de objeto, lista las clases y si la aplica o no.
o Directivas personalizadas
    como un ngStyle o ngClass pero propio. Maneja la apariencia de un elemento.
    ng g d directivas/resaltar
    no tienen ni vista ni css. solo el selector, para interactuar los atributos
    el app.module lo incorpora como componenete en ls declaraciones
    ElementRef: referenciar al elemento donde incluyo la directiva
    el selector de directiva, le puedo pasar un dato tambien
    No me salio.

#FORMULARIOS
o Template Driven
    El formulario trabaja con el name, ngModel relacionado con eso, bidireccionalmente.
o Reactive Form
    Las funciones son pasivas. Hacen algo cuando las llamas con parametros.
    Reactivo es una funcion activa y el que la consume es pasivo. O sea al revez. Metes cambios para que se activen los que la consumen.
    Agrego en app.module los FormsModule y en los imports el REactiveFormsModule
    No usa el ngModel. El name se llama FormControlName que provee este modulo nuevo. Es como ngModel + name.
    Id, input, class queda igual.
    El contenedor form hay que relacionar el formulario con un objeto a crear en la clase con los datos de entrada de este form.
    Al constructor hay que pasarle (inyeccion de dependencias => importar una clase externa dentro de un objeto, lo meto en el constructor) le inyecto el form builder.
    Relacionar el formulario de formBuilder con el formulario posta reactivo del html con el [formGroup]
    Los datos estan dentro del objeto del form.value
    Warning mismo id entre diferentes formularios.
    VALIDAR: template driven uso required. no son muy seguras. El form reactivo  puede validar diferente y mejor, usamos el Validators.
    ESTADOS:
    form.valid: todo el formulario cumples validaciones de lo marcado => true, si alguno no cumple, es false.
    form.dirty: algun campo se toco, se escribio algo. El contrario es pristine. Ambos boolean.
    touched: toco un campo y lo abandono. tambien boolean. touched y untouched.
    Validaciones personalizadas: yo valido en funcion de algo.

#SERVICIOS
    Son clases. Se inyectan en los constructores de las clases de los componentes (inyectar: importar una clase en el constructor de otra).
    Esa clase hereda los funcionamientos de la clase importada. Desacoplamiento del objeto importado y el propio.
    ng g s servicios/clientes
    Tiene el decorador @Injectable
    providedIn se autoproveen
    Consumir servicios y sus datos desde cualquier componente. Brinda informacion comun a todos los componentes.
      constructor(private clientesService: ClientesService) { } puede acceder a sus metodos y propiedades
    Si no tuviera el providedIn no funciona. Proveer el servicio! Si no de esa forma, desde los providers del app.module:
        providers: [ClienteService, ...]
    providedIn, desde el app.module esta para todo el proyecto.
    Si el comomponente tiene sus providers, meto el servicio y es solo para ese componente
    (Interface: que el servicio implemente la interface, no el componente)
    Configurar Servicios:
    - El nombre del servicio coincide con el nombre de su clase.
    Vamos a usar: https://www.mockapi.io/ como backend persistente.
        Te loggeas. Genero proyecto. Tenes un endpoint donde van a esar mis arrays de objetos.
        El recurso viene con los GET, POST, PUT y DELETE ya armados
        Uso faker para crear datos. npm faker: https://www.npmjs.com/package/faker
    Otro backend pero no persistente: jsonplaceholder.typicode.com
    Creo componente y servicio Usuarios
    Clase httpClient:
    - get devuelve un observable: publicador de info, necesito subscriptores.
    retorno el observable para usar en el usuarios component
INTERFACE: de un servicio.
En el mismo .service o un archivo aparte. Es un contrato de clase, su molde.
En vez de httpClient tambien podemos usar fetch. Se puede usar cualquiera de los dos.



PROMESAS Y OBSERVABLES
 Promesa se rechaza o se cumple
 Observable queda